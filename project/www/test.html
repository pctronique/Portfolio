<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./src/css/normalizer.css" />
    <link rel="stylesheet" href="./src/css/font.css" />
    <link rel="stylesheet" href="./src/css/style_default.css" />
    <link rel="stylesheet" href="./src/css/texte_3d.css" />
    <link rel="stylesheet" href="./src/css/triangle_3d_test.css" />
    <link rel="stylesheet" href="./src/css/object_glass.css" />
    <style>
			#blocker {
				position: absolute;
				top: 0;
				left: 0;
				bottom: 0;
				right: 0;
			}

      a {
        color: #ff0;
        text-decoration: none;
      }
      
      a:hover {
        text-decoration: underline;
      }
      
      button {
        cursor: pointer;
        text-transform: uppercase;
      }
      
      #info {
        position: absolute;
        top: 0px;
        width: 100%;
        padding: 10px;
        box-sizing: border-box;
        text-align: center;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select: none;
        user-select: none;
        pointer-events: none;
        z-index: 1; /* TODO Solve this in HTML */
      }
      
      a, button, input, select {
        pointer-events: auto;
      }
      
      .lil-gui {
        z-index: 2 !important; /* TODO Solve this in HTML */
      }
      
      @media all and ( max-width: 640px ) {
        .lil-gui.root { 
          right: auto;
          top: auto;
          max-height: 50%;
          max-width: 80%;
          bottom: 0;
          left: 0;
        }
      }
      
      #overlay {
        position: absolute;
        font-size: 16px;
        z-index: 2;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        background: rgba(0,0,0,0.7);
      }
      
        #overlay button {
          background: transparent;
          border: 0;
          border: 1px solid rgb(255, 255, 255);
          border-radius: 4px;
          color: #ffffff;
          padding: 12px 18px;
          text-transform: uppercase;
          cursor: pointer;
        }
      
      #notSupported {
        width: 50%;
        margin: auto;
        background-color: #f00;
        margin-top: 20px;
        padding: 10px;
      }

      #text_3d {
        position: absolute;
        margin-top: -370px;
        width: 800px;
        height: 200px;
      }
		</style>
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <title>Portfolio</title>
  </head>
  <body>
    <header>
      <div class="menu-and-bt" id="menu-and-bt-left">
        <input
          type="checkbox"
          name="check-nav-left"
          id="check-nav-left"
          class="check-nav"
        />
        <figure id="nav-left" class="nav-default">
          <ul>
            <li class="lien"><a class="click-lien" href="./">Accueil</a></li>
            <li>
              Projects
              <ul class="submenu">
                <li class="lien"><a class="click-lien" href="./?ind=cat&cat=web">Web</a></li>
                <li class="lien"><a class="click-lien" href="./?ind=cat&cat=java">Java</a></li>
              </ul>
            </li>
            <li class="lien"><a class="click-lien" href="./?ind=comp">Conpétences</a></li>
            <li class="lien"><a class="click-lien" href="./?ind=parc">Parcours</a></li>
          </ul>
        </figure>
        <label id="bt-nav-left" class="bt-nav-default" for="check-nav-left">
          <img id="img-nav-left" src="./src/img/menu-white.svg" alt="" />
        </label>
      </div>
      <h1 id="txt_matrix">Ludovic NAULOT</h1>

      <div class="menu-and-bt" id="menu-and-bt-right">
        <input
          type="checkbox"
          name="check-nav-right"
          id="check-nav-right"
          class="check-nav"
        />
        <label id="bt-nav-right" class="bt-nav-default" for="check-nav-right">
          <img id="img-nav-right" src="./src/img/cadenas-ferme-white.svg" alt="" />
        </label>
        <nav id="nav-right" class="nav-default">
          <p>Accèx utilisateur</p>
        </nav>
      </div>
    </header>
    <section>
      <p id="choix-background">BINARY</p>
      <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - procedural 3D text<br/>
        type to enter new text, drag to spin the text<br/>
        <button id="color">change color</button>
        <button id="font">change font</button>
        <button id="weight">change weight</button>
        <button id="bevel">change bevel</button><br/>
        <a id="permalink" href="#">permalink</a>
      </div>
      <div id="text_3d"></div>
      <div id="container"></div>
      <div id="blocker"></div>
    </section>
    <canvas id="body_matrix"></canvas>
    <footer>
      <ul>
        <li><a href="./?ind=msg">Contact</a></li>
        <li><a href="./?ind=legales"></a>Mentions Légales</li>
      </ul>
      <ul id="taking">
        <li><a href="https://github.com/pctronique"><img src="./src/img/signe-github.svg" alt="" /></a></li>
        <li><a href="https://www.linkedin.com/in/ludovic-naulot-0451284b"><img src="./src/img/linkedin.svg" alt="" /></a></li>
      </ul>
    </footer>
    <script src="./src/js/mwgokv.js"></script>
    <script src="./src/js/menu.js"></script>
    <script src="./src/js/object_glass.js"></script>
    <script src="./src/js/le_fetch.js"></script>
    <script src="./src/js/connexion.js"></script>
		<script type="importmap">
			{
				"imports": {
					"three": "./src/bin/three_js/build/three.module.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { TrackballControls } from './src/bin/three_js/examples/jsm/controls/TrackballControls.js';
			import { CSS3DRenderer, CSS3DObject } from './src/bin/three_js/examples/jsm/renderers/CSS3DRenderer.js';

			let camera, scene, renderer;
			let controls;

			function Element( id, x, y, z, ry ) {

				const div = document.createElement( 'div' );
				div.style.width = '480px';
				div.style.height = '360px';
				div.style.backgroundColor = '#000';

				const iframe = document.createElement( 'iframe' );
				iframe.style.width = '480px';
				iframe.style.height = '360px';
				iframe.style.border = '0px';
				iframe.src = [ 'https://www.youtube.com/embed/', id, '?rel=0' ].join( '' );
				div.appendChild( iframe );

				const object = new CSS3DObject( div );
				object.position.set( x, y, z );
				object.rotation.y = ry;

				return object;

			}

			init();
			animate();

			function init() {

				const container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 5000 );
				camera.position.set( 500, 350, 750 );

				scene = new THREE.Scene();

				renderer = new CSS3DRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				const group = new THREE.Group();
				group.add( new Element( 'SJOz3qjfQXU', 0, 0, 240, 0 ) );
				group.add( new Element( 'Y2-xZ-1HE-Q', 240, 0, 0, Math.PI / 2 ) );
				group.add( new Element( 'IrydklNpcFI', 0, 0, - 240, Math.PI ) );
				group.add( new Element( '9ubytEsCaS0', - 240, 0, 0, - Math.PI / 2 ) );
				scene.add( group );

				controls = new TrackballControls( camera, renderer.domElement );
				controls.rotateSpeed = 4;

				window.addEventListener( 'resize', onWindowResize );

				// Block iframe events when dragging camera

				const blocker = document.getElementById( 'blocker' );
				blocker.style.display = 'none';

				controls.addEventListener( 'start', function () {

					blocker.style.display = '';

				} );
				controls.addEventListener( 'end', function () {

					blocker.style.display = 'none';

				} );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );
				controls.update();
				renderer.render( scene, camera );

			}

		</script>

    <script type="module">

			import * as THREE from 'three';

			import { FontLoader } from './src/bin/three_js/examples/jsm/loaders/FontLoader.js';
			import { TextGeometry } from './src/bin/three_js/examples/jsm/geometries/TextGeometry.js';

			import Stats from './src/bin/three_js/examples/jsm/libs/stats.module.js';

			THREE.Cache.enabled = true;

			let container, stats, permalink, hex;

			let camera1, cameraTarget, scene1, renderer1;

			let group, textMesh1, textMesh2, textGeo, materials;

			let firstLetter = true;

			let text = 'three.js',

				bevelEnabled = true,

				font = undefined,

				fontName = 'optimer', // helvetiker, optimer, gentilis, droid sans, droid serif
				fontWeight = 'bold'; // normal bold

			const height = 20,
				size = 70,
				hover = 30,

				curveSegments = 4,

				bevelThickness = 2,
				bevelSize = 1.5;

			const mirror = true;

			const fontMap = {

				'helvetiker': 0,
				'optimer': 1,
				'gentilis': 2,
				'droid/droid_sans': 3,
				'droid/droid_serif': 4

			};

			const weightMap = {

				'regular': 0,
				'bold': 1

			};

			const reverseFontMap = [];
			const reverseWeightMap = [];

			for ( const i in fontMap ) reverseFontMap[ fontMap[ i ] ] = i;
			for ( const i in weightMap ) reverseWeightMap[ weightMap[ i ] ] = i;

			let targetRotation = 0;
			let targetRotationOnPointerDown = 0;

			let pointerX = 0;
			let pointerXOnPointerDown = 0;

			let windowHalfX = window.innerWidth / 2;

			let fontIndex = 1;

			init();
			animate();

			function decimalToHex( d ) {

				let hex = Number( d ).toString( 16 );
				hex = '000000'.substring( 0, 6 - hex.length ) + hex;
				return hex.toUpperCase();

			}

			function init() {

				container = document.getElementById("text_3d");
				//document.body.appendChild( container );

				permalink = document.getElementById( 'permalink' );

				// CAMERA

				camera1 = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 1500 );
				camera1.position.set( 0, 400, 700 );

				cameraTarget = new THREE.Vector3( 0, 150, 0 );

				// SCENE

				scene1 = new THREE.Scene();
				//scene1.background = new THREE.Color( 0x000000 );
				//scene1.fog = new THREE.Fog( 0x000000, 250, 1400 );

				// LIGHTS

				const dirLight = new THREE.DirectionalLight( 0xffffff, 0.125 );
				dirLight.position.set( 0, 0, 1 ).normalize();
				scene1.add( dirLight );

				const pointLight = new THREE.PointLight( 0xffffff, 1.5 );
				pointLight.position.set( 0, 100, 90 );
				scene1.add( pointLight );

				// Get text from hash

				const hash = document.location.hash.slice( 1 );

				if ( hash.length !== 0 ) {

					const colorhash = hash.substring( 0, 6 );
					const fonthash = hash.substring( 6, 7 );
					const weighthash = hash.substring( 7, 8 );
					const bevelhash = hash.substring( 8, 9 );
					const texthash = hash.substring( 10 );

					hex = colorhash;
					pointLight.color.setHex( parseInt( colorhash, 16 ) );

					fontName = reverseFontMap[ parseInt( fonthash ) ];
					fontWeight = reverseWeightMap[ parseInt( weighthash ) ];

					bevelEnabled = parseInt( bevelhash );

					text = decodeURI( texthash );

					updatePermalink();

				} else {

					pointLight.color.setHSL( Math.random(), 1, 0.5 );
					hex = decimalToHex( pointLight.color.getHex() );

				}

				materials = [
					new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } ), // front
					new THREE.MeshPhongMaterial( { color: 0xffffff } ) // side
				];

				group = new THREE.Group();
				group.position.y = 100;

				scene1.add( group );

				loadFont();

				/*const plane = new THREE.Mesh(
					new THREE.PlaneGeometry( 10000, 10000 ),
					new THREE.MeshBasicMaterial( { color: 0xffffff, opacity: 0.5, transparent: true } )
				);
				plane.position.y = 100;
				plane.rotation.x = - Math.PI / 2;
				scene1.add( plane );*/

				// RENDERER

				renderer1 = new THREE.WebGLRenderer( { alpha: true } );
				renderer1.setPixelRatio( window.devicePixelRatio );
				renderer1.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer1.domElement );

				// STATS

				stats = new Stats();
				container.appendChild( stats.dom );

				// EVENTS

				container.style.touchAction = 'none';
				container.addEventListener( 'pointerdown', onPointerDown );

				document.addEventListener( 'keypress', onDocumentKeyPress );
				document.addEventListener( 'keydown', onDocumentKeyDown );

				document.getElementById( 'color' ).addEventListener( 'click', function () {

					pointLight.color.setHSL( Math.random(), 1, 0.5 );
					hex = decimalToHex( pointLight.color.getHex() );

					updatePermalink();

				} );

				document.getElementById( 'font' ).addEventListener( 'click', function () {

					fontIndex ++;

					fontName = reverseFontMap[ fontIndex % reverseFontMap.length ];

					loadFont();

				} );


				document.getElementById( 'weight' ).addEventListener( 'click', function () {

					if ( fontWeight === 'bold' ) {

						fontWeight = 'regular';

					} else {

						fontWeight = 'bold';

					}

					loadFont();

				} );

				document.getElementById( 'bevel' ).addEventListener( 'click', function () {

					bevelEnabled = ! bevelEnabled;

					refreshText();

				} );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;

				camera1.aspect = window.innerWidth / window.innerHeight;
				camera1.updateProjectionMatrix();

				renderer1.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function boolToNum( b ) {

				return b ? 1 : 0;

			}

			function updatePermalink() {

				const link = hex + fontMap[ fontName ] + weightMap[ fontWeight ] + boolToNum( bevelEnabled ) + '#' + encodeURI( text );

				permalink.href = '#' + link;
				window.location.hash = link;

			}

			function onDocumentKeyDown( event ) {

				if ( firstLetter ) {

					firstLetter = false;
					text = '';

				}

				const keyCode = event.keyCode;

				// backspace

				if ( keyCode == 8 ) {

					event.preventDefault();

					text = text.substring( 0, text.length - 1 );
					refreshText();

					return false;

				}

			}

			function onDocumentKeyPress( event ) {

				const keyCode = event.which;

				// backspace

				if ( keyCode == 8 ) {

					event.preventDefault();

				} else {

					const ch = String.fromCharCode( keyCode );
					text += ch;

					refreshText();

				}

			}

			function loadFont() {

				const loader = new FontLoader();
				loader.load( 'src/bin/three_js/examples/fonts/' + fontName + '_' + fontWeight + '.typeface.json', function ( response ) {

					font = response;

					refreshText();

				} );

			}

			function createText() {

				textGeo = new TextGeometry( text, {

					font: font,

					size: size,
					height: height,
					curveSegments: curveSegments,

					bevelThickness: bevelThickness,
					bevelSize: bevelSize,
					bevelEnabled: bevelEnabled

				} );

				textGeo.computeBoundingBox();

				const centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

				textMesh1 = new THREE.Mesh( textGeo, materials );

				textMesh1.position.x = centerOffset;
				textMesh1.position.y = hover;
				textMesh1.position.z = 0;

				textMesh1.rotation.x = 0;
				textMesh1.rotation.y = Math.PI * 2;

				group.add( textMesh1 );

				if ( mirror ) {

					textMesh2 = new THREE.Mesh( textGeo, materials );

					textMesh2.position.x = centerOffset;
					textMesh2.position.y = - hover;
					textMesh2.position.z = height;

					textMesh2.rotation.x = Math.PI;
					textMesh2.rotation.y = Math.PI * 2;

					group.add( textMesh2 );

				}

			}

			function refreshText() {

				updatePermalink();

				group.remove( textMesh1 );
				if ( mirror ) group.remove( textMesh2 );

				if ( ! text ) return;

				createText();

			}

			function onPointerDown( event ) {

				if ( event.isPrimary === false ) return;

				pointerXOnPointerDown = event.clientX - windowHalfX;
				targetRotationOnPointerDown = targetRotation;

				document.addEventListener( 'pointermove', onPointerMove );
				document.addEventListener( 'pointerup', onPointerUp );

			}

			function onPointerMove( event ) {

				if ( event.isPrimary === false ) return;

				pointerX = event.clientX - windowHalfX;

				targetRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;

			}

			function onPointerUp() {

				if ( event.isPrimary === false ) return;

				document.removeEventListener( 'pointermove', onPointerMove );
				document.removeEventListener( 'pointerup', onPointerUp );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;

				camera1.lookAt( cameraTarget );

				renderer1.clear();
				renderer1.render( scene1, camera1 );

			}

		</script>
  </body>
</html>
