<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./src/css/normalizer.css" />
    <link rel="stylesheet" href="./src/css/font.css" />
    <link rel="stylesheet" href="./src/css/style_default.css" />
    <link rel="stylesheet" href="./src/css/texte_3d.css" />
    <link rel="stylesheet" href="./src/css/triangle_3d_test.css" />
    <link rel="stylesheet" href="./src/css/object_glass.css" />
    <style></style>
    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>
    <title>Portfolio</title>
  </head>
  <body>
    <header>
      <div class="menu-and-bt" id="menu-and-bt-left">
        <input
          type="checkbox"
          name="check-nav-left"
          id="check-nav-left"
          class="check-nav"
        />
        <figure id="nav-left" class="nav-default">
          <ul>
            <li class="lien"><a class="click-lien" href="./">Accueil</a></li>
            <li>
              Projects
              <ul class="submenu">
                <li class="lien">
                  <a class="click-lien" href="./?ind=cat&cat=web">Web</a>
                </li>
                <li class="lien">
                  <a class="click-lien" href="./?ind=cat&cat=java">Java</a>
                </li>
              </ul>
            </li>
            <li class="lien">
              <a class="click-lien" href="./?ind=comp">Conpétences</a>
            </li>
            <li class="lien">
              <a class="click-lien" href="./?ind=parc">Parcours</a>
            </li>
          </ul>
        </figure>
        <label id="bt-nav-left" class="bt-nav-default" for="check-nav-left">
          <img id="img-nav-left" src="./src/img/menu-white.svg" alt="" />
        </label>
      </div>
      <h1 id="txt_matrix">Ludovic NAULOT</h1>

      <div class="menu-and-bt" id="menu-and-bt-right">
        <input
          type="checkbox"
          name="check-nav-right"
          id="check-nav-right"
          class="check-nav"
        />
        <label id="bt-nav-right" class="bt-nav-default" for="check-nav-right">
          <img
            id="img-nav-right"
            src="./src/img/cadenas-ferme-white.svg"
            alt=""
          />
        </label>
        <nav id="nav-right" class="nav-default">
          <p>Accèx utilisateur</p>
        </nav>
      </div>
    </header>
    <section>
      <input
        type="hidden"
        id="text_title_pg"
        name="text_title_pg"
        value="test"
      />
      <figure id="title_pg"></figure>
    </section>
    <canvas id="body_matrix"></canvas>
    <footer>
      <ul>
        <li><a href="./?ind=msg">Contact</a></li>
        <li><a href="./?ind=legales"></a>Mentions Légales</li>
      </ul>
      <ul id="taking">
        <li>
          <a href="https://github.com/pctronique"
            ><img src="./src/img/signe-github.svg" alt=""
          /></a>
        </li>
        <li>
          <a href="https://www.linkedin.com/in/ludovic-naulot-0451284b"
            ><img src="./src/img/linkedin.svg" alt=""
          /></a>
        </li>
      </ul>
    </footer>
    <script src="./src/js/mwgokv.js"></script>
    <script src="./src/js/menu.js"></script>
    <script src="./src/js/object_glass.js"></script>
    <script src="./src/js/le_fetch.js"></script>
    <script src="./src/js/connexion.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "./src/bin/three_js/build/three.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      import { FontLoader } from "./src/bin/three_js/examples/jsm/loaders/FontLoader.js";
      import { TextGeometry } from "./src/bin/three_js/examples/jsm/geometries/TextGeometry.js";

      import Stats from "./src/bin/three_js/examples/jsm/libs/stats.module.js";

      THREE.Cache.enabled = true;

      let container, stats, permalink, hex;

      let camera1, cameraTarget, scene1, renderer1;

      let group, textMesh1, textMesh2, textGeo, materials;

      let firstLetter = true;

      let text = document.getElementById("text_title_pg").value,
        bevelEnabled = true,
        font = undefined,
        fontName = "optimer", // helvetiker, optimer, gentilis, droid sans, droid serif
        fontWeight = "bold"; // normal bold

      const height = 20,
        size = 70,
        hover = 30,
        curveSegments = 4,
        bevelThickness = 2,
        bevelSize = 1.5;

      const mirror = true;

      const fontMap = {
        helvetiker: 0,
        optimer: 1,
        gentilis: 2,
        "droid/droid_sans": 3,
        "droid/droid_serif": 4,
      };

      const weightMap = {
        regular: 0,
        bold: 1,
      };

      let targetRotation = 0;
      let targetRotationOnPointerDown = 0;

      let pointerX = 0;
      let pointerXOnPointerDown = 0;

      let windowHalfX = window.innerWidth / 2;

      let fontIndex = 1;

      init();
      animate();

		function decimalToHex( d ) {

			let hex = Number( d ).toString( 16 );
			hex = '000000'.substring( 0, 6 - hex.length ) + hex;
			return hex.toUpperCase();

		}

      function init() {
        container = document.getElementById("title_pg");

        // CAMERA

        camera1 = new THREE.PerspectiveCamera(
          30,
          window.innerWidth / window.innerHeight,
          1,
          1500
        );
        camera1.position.set(0, 400, 700);

        cameraTarget = new THREE.Vector3(0, 150, 0);

        // SCENE

        scene1 = new THREE.Scene();
        //scene1.background = new THREE.Color( 0x000000 );
        //scene1.fog = new THREE.Fog( 0x000000, 250, 1400 );

        // LIGHTS

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.125);
        dirLight.position.set(0, 0, 1).normalize();
        scene1.add(dirLight);

        const pointLight = new THREE.PointLight(0xffffff, 1.5);
        pointLight.position.set(0, 100, 90);
        scene1.add(pointLight);

        // Get text from hash

        const hash = document.location.hash.slice(1);

        if (hash.length !== 0) {
          const colorhash = hash.substring(0, 6);
          const fonthash = hash.substring(6, 7);
          const weighthash = hash.substring(7, 8);
          const bevelhash = hash.substring(8, 9);
          const texthash = hash.substring(10);

          hex = colorhash;
          pointLight.color.setHex(parseInt(colorhash, 16));

          fontName = reverseFontMap[parseInt(fonthash)];
          fontWeight = reverseWeightMap[parseInt(weighthash)];

          bevelEnabled = parseInt(bevelhash);

          text = decodeURI(texthash);

          updatePermalink();
        } else {
          pointLight.color.setHSL(Math.random(), 1, 0.5);
          hex = decimalToHex(pointLight.color.getHex());
        }

        materials = [
          new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true }), // front
          new THREE.MeshPhongMaterial({ color: 0xffffff }), // side
        ];

        group = new THREE.Group();
        group.position.y = 100;

        scene1.add(group);

        loadFont();

        /*const plane = new THREE.Mesh(
	new THREE.PlaneGeometry( 10000, 10000 ),
	new THREE.MeshBasicMaterial( { color: 0xffffff, opacity: 0.5, transparent: true } )
);
plane.position.y = 100;
plane.rotation.x = - Math.PI / 2;
scene1.add( plane );*/

        // RENDERER

        renderer1 = new THREE.WebGLRenderer({ alpha: true });
        renderer1.setPixelRatio(window.devicePixelRatio);
        renderer1.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer1.domElement);

        // STATS

        stats = new Stats();
        container.appendChild(stats.dom);

        // EVENTS

        container.style.touchAction = "none";
        container.addEventListener("pointerdown", onPointerDown);

        document.addEventListener("keypress", onDocumentKeyPress);
        document.addEventListener("keydown", onDocumentKeyDown);

        
        document.getElementById("bevel").addEventListener("click", function () {
          bevelEnabled = !bevelEnabled;

          refreshText();
        });

        //

        window.addEventListener("resize", onWindowResize);
      }

      function onWindowResize() {
        windowHalfX = window.innerWidth / 2;

        camera1.aspect = window.innerWidth / window.innerHeight;
        camera1.updateProjectionMatrix();

        renderer1.setSize(window.innerWidth, window.innerHeight);
      }

      //

      function boolToNum(b) {
        return b ? 1 : 0;
      }

      function updatePermalink() {
        const link =
          hex +
          fontMap[fontName] +
          weightMap[fontWeight] +
          boolToNum(bevelEnabled) +
          "#" +
          encodeURI(text);

        permalink.href = "#" + link;
        window.location.hash = link;
      }

      function onDocumentKeyDown(event) {
        if (firstLetter) {
          firstLetter = false;
          text = "";
        }

        const keyCode = event.keyCode;

        // backspace

        if (keyCode == 8) {
          event.preventDefault();

          text = text.substring(0, text.length - 1);
          refreshText();

          return false;
        }
      }

      function onDocumentKeyPress(event) {
        const keyCode = event.which;

        // backspace

        if (keyCode == 8) {
          event.preventDefault();
        } else {
          const ch = String.fromCharCode(keyCode);
          text += ch;

          refreshText();
        }
      }

      function loadFont() {
        const loader = new FontLoader();
        loader.load(
          "src/bin/three_js/examples/fonts/" +
            fontName +
            "_" +
            fontWeight +
            ".typeface.json",
          function (response) {
            font = response;

            refreshText();
          }
        );
      }

      function createText() {
        textGeo = new TextGeometry(text, {
          font: font,

          size: size,
          height: height,
          curveSegments: curveSegments,

          bevelThickness: bevelThickness,
          bevelSize: bevelSize,
          bevelEnabled: bevelEnabled,
        });

        textGeo.computeBoundingBox();

        /*const centerOffset =
          -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);

        textMesh1 = new THREE.Mesh(textGeo, materials);

        textMesh1.position.x = centerOffset;
        textMesh1.position.y = hover;
        textMesh1.position.z = 0;

        textMesh1.rotation.x = 0;
        textMesh1.rotation.y = Math.PI * 2;

        group.add(textMesh1);*/

        if (mirror) {
          textMesh2 = new THREE.Mesh(textGeo, materials);

          textMesh2.position.x = centerOffset;
          textMesh2.position.y = -hover;
          textMesh2.position.z = height;

          textMesh2.rotation.x = Math.PI;
          textMesh2.rotation.y = Math.PI * 2;

          group.add(textMesh2);
        }
      }

      function refreshText() {
        updatePermalink();

        group.remove(textMesh1);
        if (mirror) group.remove(textMesh2);

        if (!text) return;

        createText();
      }

      function onPointerDown(event) {
        if (event.isPrimary === false) return;

        pointerXOnPointerDown = event.clientX - windowHalfX;
        targetRotationOnPointerDown = targetRotation;

        document.addEventListener("pointermove", onPointerMove);
        document.addEventListener("pointerup", onPointerUp);
      }

      function onPointerMove(event) {
        if (event.isPrimary === false) return;

        pointerX = event.clientX - windowHalfX;

        targetRotation =
          targetRotationOnPointerDown +
          (pointerX - pointerXOnPointerDown) * 0.02;
      }

      function onPointerUp() {
        if (event.isPrimary === false) return;

        document.removeEventListener("pointermove", onPointerMove);
        document.removeEventListener("pointerup", onPointerUp);
      }

      //

      function animate() {
        requestAnimationFrame(animate);

        render();
        stats.update();
      }

      function render() {
        group.rotation.y += (targetRotation - group.rotation.y) * 0.05;

        camera1.lookAt(cameraTarget);

        renderer1.clear();
        renderer1.render(scene1, camera1);
      }
    </script>
  </body>
</html>
